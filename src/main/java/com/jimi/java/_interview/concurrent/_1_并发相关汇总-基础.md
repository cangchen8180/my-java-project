## 并发相关汇总-基础

### 多线程
#### 1、java中有几种方法可以实现一个线程？
答：实现Runnable、Callable，或者继承Thread。

#### 2、如何停止一个正在运行的线程？
答：定义一个volatile全局变量，如private volatile static boolean running = false;在运行线程线程中循环读这个变量，其它线程中修改这个变量。

另外，正在运行的线程，可以使用线程中断的方法停止线程。

#### 3、notify()和notifyAll()有什么区别？
答：notify是随机唤醒一个等待某个资源的线程，进入就绪队列等待CPU的调度; 
notifyAll是唤醒所有的，进入就绪队列等待CPU调度。

#### 4、sleep()和 wait()有什么区别？
答：sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。在调用sleep()方法的过程中，线程不会释放对象锁。

当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。

#### 5、什么是Daemon线程？它有什么意义？
答：在Java中有两类线程：用户线程 (User Thread)、守护线程 (Daemon Thread)。
 
Daemon的作用是为其他线程的运行提供服务，比如说GC线程。其实User Thread线程和Daemon Thread守护线程本质上来说去没啥区别的，唯一的区别之处就在虚拟机的离开：如果User Thread全部退出，那么Daemon Thread也就没啥线程好服务的了，所以虚拟机也就退出了。

注：设置守护线程，使用thread.setDaemon(true)，如

```java
Thread thread = new Thread(new DaemonRunner());
// 设置为守护进程
thread.setDaemon(true);
thread.start();
```        

但thread.setDaemon(true)必须在thread.start()之前设置，否则会跑出一个IllegalThreadStateException异常，你不能把正在运行的常规线程设置为守护线程。

实际应用中的例子：
web服务器中的Servlet，容器启动时后台初始化一个服务线程，即调度线程，负责处理http请求，然后每个请求过来调度线程从线程池中取出一个工作者线程来处理该请求，从而实现并发控制的目的。

#### 6、java如何实现多线程之间的通讯和协作？
答：可以使用synchronized/notify/notifyAll以及Lock/Condition, CyclicBarrier/Semaphore/CountdownLatch。

### 锁

#### 1、什么是可重入锁（ReentrantLock）？
答：可重入锁的概念是自己可以再次获取自己的内部锁。举个例子，比如一条线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的（如果不可重入的锁的话，此刻会造成死锁）。

#### 2、当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?
答：可以进入其他非synchronized的方法，其他synchronized的方法是不可以的！

Java中的每个对象都有一个锁（lock）或者叫做监视器（monitor），当访问某个对象的synchronized方法时，表示的将该对象上锁，此时其他任何线程都无法再去访问该synchronized方法了，直到之前的那个线程执行方法完毕后（或者是抛出了异常），才将该对象的锁释放掉，其他线程才有可能再去访问该synchronized方法。

如果一个对象有多个synchronized方法，某一时刻某个线程已经进入到了某个synchronized方法，那么在该方法没有执行完毕前，其他线程是无法访问该对象的任何synchronized方法的。

另外，如果其他synchronized方法是静态的方法，它用的同步锁是当前类的字节码，与非静态的方法不能同步，因此，静态方法可以被调用。

#### 3、synchronized和java.util.concurrent.locks.Lock的异同？
答：相比synchronized，Lock功能更丰富，但随着JDK1.6对synchronized的优化，性能有了很大提升，除需要公平锁、可响应中断锁（synchronized不响应块内的线程中断）等特殊情况以外，还是建议使用synchronized同步线程。

#### 4、乐观锁和悲观锁的理解及如何实现，有哪些实现方式？
答：乐观锁，每次操作时不加锁而是假设没有冲突而去完成某项操作，如果因为提交更新时检测到冲突，就返回错误给用户，一般是进行失败重试，直到成功为止。
悲观锁，是必须先拿到锁，这样会导致其它所有需要锁的线程挂起（await），等待持有锁的线程释放锁。

> 在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。
  数据版本，为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。

悲观锁可以使用synchronized以及Lock。
乐观锁可以使用volatile+CAS（Compare and Swap）原语实现，但这种实现会存在ABA问题; 也有部分乐观锁实现是采用版本号方式，如数据库操作。

附：CAS说明
---
**CAS**
CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。

CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前值。）CAS 有效地说明了“ 我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。 ”这其实和乐观锁的冲突检查+数据更新的原理是一样的。

这里再强调一下， **乐观锁是一种思想。CAS是这种思想的一种实现方式。**

**Java对CAS的支持**

在JDK1.5 中新增 java.util.concurrent (J.U.C)就是建立在CAS之上的。相对于对于 synchronized 这种阻塞算法，CAS是非阻塞算法的一种常见实现。所以J.U.C在性能上有了很大的提升。

我们以 java.util.concurrent 中的 AtomicInteger 为例，看一下在不使用锁的情况下是如何保证线程安全的。主要理解 getAndIncrement 方法，该方法的作用相当于 ++i 操作。

```java
public class AtomicInteger extends Number implements java.io.Serializable {  

    private volatile int value;  

    public final int get() {  
        return value;  
    }  

    public final int getAndIncrement() {  
        for (;;) {  
            int current = get();  
            int next = current + 1;  
            if (compareAndSet(current, next))  
                return current;  
        }  
    }  

    public final boolean compareAndSet(int expect, int update) {  
        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);  
    }  
}
```

在没有锁的机制下需要字段value要借助volatile原语，保证线程间的数据是可见的。这样在获取变量的值的时候才能直接读取。然后来看看 ++i 是怎么做到的。

getAndIncrement 采用了CAS操作，每次从内存中读取数据然后将此数据和 +1 后的结果进行CAS操作，如果成功就返回结果，否则重试直到成功为止。而 compareAndSet 利用JNI来完成CPU指令的操作。

**ABA问题**

CAS会导致“ABA问题”。

CAS算法实现一个重要前提需要取出内存中某时刻的数据，而在下时刻比较并替换，那么在这个时间差类会导致数据的变化。

比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。

部分乐观锁的实现是通过版本号（ version ）的方式来解决ABA问题，乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行 +1 操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现ABA问题，因为版本号只会增加不会减少。

### 并发框架

#### SynchronizedMap和ConcurrentHashMap有什么区别？
答：


