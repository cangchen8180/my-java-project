## mysql存储亿级数据时，如何优化？

### 查询语句优化

对于复杂查询，使用explain分析（主要看type、extra等字段）。

语句优化：
- 应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：

```mysql
select id from t where num = 20 or num = 30;
```

应改为：
    
```mysql
select id from t where num = 20
union all
select id from t where num = 30;
```
    
说明（☆）：如果SQL语句的优化牺牲了可读性，并且性能的提高不是很大（如0.5秒到0.4秒），需要一定的量才能看出效果，还不如不去优化（如上图的例子）。。
    所以，此处列出的sql优化并不是绝对的，要结合经验综合考量
    
- join的优化

    如果你的应用程序有很多JOIN查询，你应该确认两个表中Join的字段是被建过索引的（否则会使用到join buffer）。

    这样，MySQL内部会启动为你优化Join语句的机制。此外，这些被用来Join的字段，应该是相同的类型的。

- 拆表、加冗余字段
    
    对于复杂操作，如编写存储过程，减少查询次数，但不易维护。

    Q1：mysql优化、执行sql的过程？
    
### 索引
使用注意：
- 一般来说，在WHERE和JOIN中出现的列需要建立索引，但也不完全如此，MySQL只对<，<=，=，>，>=，BETWEEN，IN，LIKE才会使用索引。
- Like语句操作的使用

     一般情况下不鼓励使用like操作，如果非使用不可，需要特别注意：like '%aaa%' 不会使用索引而like 'aaa%'可以使用索引。

- 不要在索引列上进行运算，在索引列上进行计算或使用函数，将导致索引失效而进行全表扫描。
- 删除重复索引
      
```mysql
CREATE TABLE ablum(
  …
  PRMIMARY KEY(album_id),
  KEY country_id(country_id), -- 根据“最左前缀”原则，该索引已经存在，故可以删除
  KEY index2(country_id, type_id)
  …
);
```
    
Q1：数据库中，索引的数据结构等，参考[MySQL索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)
    
### 主从复制，读写分离

### 分区（mysql5.1后支持）
分区方式：range、list、hash、linear等

子分区，使用注意：

- 分区的字段不能有NULL值，因为比如hash(null)为映射成0，违背最初hash的目的。
- 索引的字段必须有分区的字段，不然查询时还是会扫描所有分区。
- 对于Range 和list类型的分区，每次进行操作时都需要遍历所有的分区条件，以判断相关的记录是属于哪个分区，如果分区的数量很多，会在选择分区上浪费较多的资源

  为了避免这种情况 可以限制分区的数目（<100）,或是选择hash分区
- 维护成本高，增加/删除分区很快捷，但是重组或者是alter分区的过程类似于alter table,会进行大量的数据复制操作，效率很低。

    **注：对于分区表的访问，最重要的一点是要在where条件中包含分区列，即使看起来是多余的，只有这样才能过滤不需要的分区，否则会访问所有的分区表。**

- 分库分表

    相对垂直拆分，水平拆分的事务处理更简单。

    可能存在的问题：如果要查所有地区的数据，分表前只需查一张表，分表后查询多张表再合并，会显得麻烦，但不一定效率就降低。
    （如上面的情况，可以启动3个线程从各个表中取数据，然后再合并一次，效率不一定会降低。但如果分了100张表，那效率肯定降低了。。。）

参考[MySQL性能优化系列教程：分库分表分区、索引及查询优化](http://www.wiquan.com/article/669)
